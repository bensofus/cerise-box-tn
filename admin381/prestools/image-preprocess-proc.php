<?php
if(!@include 'approve.php') die( "approve.php was not found!");

/* Note: this script uses only the PHP GD library. Prestashop uses php_image_magician as a shell around that (admin/filemanager/include/php_image_magician.php) */

$indexfile = '<?php
/*
* Index file generated by Prestools for Prestashop and Thirty Bees
*/

header("Expires: Mon, 26 Jul 1997 05:00:00 GMT");
header("Last-Modified: ".gmdate("D, d M Y H:i:s")." GMT");

header("Cache-Control: no-store, no-cache, must-revalidate");
header("Cache-Control: post-check=0, pre-check=0", false);
header("Pragma: no-cache");

header("Location: ../");
exit;
';

$starttime=time();
$library = intval($_POST["glibrary"]);

$topcut = intval($_POST["topcut"]);
$rightcut = intval($_POST["rightcut"]);
$bottomcut = intval($_POST["bottomcut"]);
$leftcut = intval($_POST["leftcut"]);
$topadd = intval($_POST["topadd"]);
$rightadd = intval($_POST["rightadd"]);
$bottomadd = intval($_POST["bottomadd"]);
$leftadd = intval($_POST["leftadd"]);
if(isset($_POST["trimflag"]))
  $trimflag = intval($_POST["trimflag"]);
else
  $trimflag = 0;
$trimcolor = $_POST["trimcolor"];
$trimcolor=str_replace("#","",$trimcolor);
if ($trimflag && ($trimcolor != "") && ((strlen($trimcolor) != 6) || (!ctype_xdigit($trimcolor))))
	pecho("Invalid trimcolor. Auto-detect chosen.");
$suffix = preg_replace("/[^0-9a-zA-Z\-_]/","",$_POST["suffix"]);

$trimtolerance = intval($_POST["trimtolerance"]);
$trimcount = intval($_POST["trimcount"]);
if(isset($_POST["cleanflag"]))
  $cleanflag = intval($_POST["cleanflag"]);
else
  $cleanflag = 0;
$cleantolerance = intval($_POST["cleantolerance"]);
$cleanreplacement = preg_replace('/[^0-9a-fA-F#]/','',$_POST["cleanreplacement"]);
$cleancolors = array();
$cleancolors[0] = hexdec(substr($cleanreplacement,1,2));
$cleancolors[1] = hexdec(substr($cleanreplacement,3,2));
$cleancolors[2] = hexdec(substr($cleanreplacement,5,2));
$fillcolor = $_POST["fillcolor"];
if($fillcolor != "")
  $fillcolor = "#".preg_replace('/[^0-9a-fA-F]/','',$fillcolor);
$duration = intval($_POST["duration"]);
$maxwidth = intval($_POST["maxwidth"]);
$maxheight = intval($_POST["maxheight"]);
$maxmargin = intval($_POST["maxmargin"]);
$maxfillcolor = $_POST["maxfillcolor"];
if($maxfillcolor != "")
  $maxfillcolor = "#".preg_replace('/[^0-9a-fA-F]/','',$maxfillcolor);

if($duration==0) $duration = 30;
set_time_limit($duration);
if($_POST["filltype"] == "colored") $filltype = "colored"; else $filltype = "empty";
if($filltype == "empty ") $fillcolor = "#000000";
$imagetype = $_POST["imagetype"];
if(!in_array($imagetype, array("jpg","png"))) $imagetype = "same";
if(isset($_POST["filter"]))
  $filter = intval($_POST["filter"]);
else
  $filter = 22; /* 22=LANCZOS */
dbquery("UPDATE ". _DB_PREFIX_."configuration SET value=0,date_upd=NOW() WHERE id_shop IS NULL AND id_shop_group IS NULL AND name='PRESTOOLS_IMPREP_STOPFLAG'");


echo '<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8">
<script>
function newwin()
{ nwin = window.open("","NewWindow", "scrollbars,menubar,toolbar, status,resizable,location");
  content = document.body.innerHTML;
  if(nwin != null)
  { nwin.document.write("<html><head><meta http-equiv=\'Content-Type\' content=\'text/html; charset=utf-8\' /></head><body>"+content+"</body></html>");
    nwin.document.close();
  }
}
</script></head><body>';

 echo '<a href="#" title="Show the content of this frame in a New Window" onclick="newwin(); return false;">NW</a> ';
 echo " <span id=finspan></span></br>";
 if($library==1)
 { echo " using Imagick";
   $filter_array = array(
imagick::FILTER_UNDEFINED => "UNDEFINED",
imagick::FILTER_POINT => "POINT",
imagick::FILTER_BOX => "BOX",
imagick::FILTER_TRIANGLE => "TRIANGLE",
imagick::FILTER_HERMITE => "HERMITE",
imagick::FILTER_HANNING => "HANNING",
imagick::FILTER_HAMMING => "HAMMING",
imagick::FILTER_BLACKMAN => "BLACKMAN",
imagick::FILTER_GAUSSIAN => "GAUSSIAN",
imagick::FILTER_QUADRATIC => "QUADRATIC",
imagick::FILTER_CUBIC => "CUBIC",
imagick::FILTER_CATROM => "CATROM",
imagick::FILTER_MITCHELL => "MITCHELL",
imagick::FILTER_LANCZOS => "LANCZOS",
imagick::FILTER_BESSEL => "BESSEL",
imagick::FILTER_SINC => "SINC");
   if($verbose=="true")
	 echo " with filter ".$filter_array[$filter]."<br>";
  }

$id_lang = get_configuration_value('PS_LANG_DEFAULT');
$generate_hight_dpi_images = get_configuration_value('PS_HIGHT_DPI');
$shownotfound = true;

if(isset($demo_mode) && $demo_mode)
{ echo '<script>alert("The script is in demo mode. Nothing is changed!");</script>';
  exit(0);
}

$targetdir = "tmp2";
if((!file_exists($targetdir)) || (!is_dir($targetdir)))
{ if(!mkdir($targetdir))
	colordie("There is no tmp2 directory and it cannot be created either");
}
$targetdir = realpath($targetdir);
$srcdir = "tmp";
if((!file_exists($srcdir)) || (!is_dir($srcdir)))
	colordie("There is no tmp directory");
$files = scandir($srcdir);
$x=0;
foreach ($files AS $file)
{ if(is_dir($srcdir.$file)) continue;
  if(($file==".") || ($file=="..")) continue;
  if((substr($file,-4)==".jpg") || (substr($file,-4)==".JPG") || (substr($file,-4)==".png") || (substr($file,-4)==".PNG"))
  {	process_image($file);
	$x++;
  }	
}

$endtime = time();
if($x == 0) { echo "No images to process!"; return; }
echo '<br>'.$x.' images/'.($endtime-$starttime).'s: '.round((($endtime-$starttime)/$x),2).'s per image';
echo '<h1>Finish</h1><script>finspan=document.getElementById("finspan"); finspan.innerHTML="<b>Finished in '.($endtime-$starttime).'s</b>"; parent.dynamo2(" end<br>");</script>';

function process_image($file)
{ global $library, $verbose;
  /* check for interuption */
  $gquery = "SELECT value FROM ". _DB_PREFIX_."configuration";
  $gquery .= ' WHERE name="PRESTOOLS_IMPREP_STOPFLAG" AND id_shop IS NULL and id_shop_group IS NULL';
  $gres = dbquery($gquery);
  if(mysqli_num_rows($gres)>0)
  { $grow = mysqli_fetch_array($gres);
    if($grow["value"]=="1")
    { $cquery="UPDATE ". _DB_PREFIX_."configuration";
      $cquery .= ' SET value=0,date_upd=NOW() WHERE id_shop IS NULL AND id_shop_group IS NULL AND name="PRESTOOLS_IMPREP_STOPFLAG"';
      dbquery($cquery);
	  pecho("Preprocessing interruped by user");
	  die("!!!");
	}
  }
  if ($verbose=="true") echo "<br>";
  pecho(" ".$file);
  if ($verbose=="true") echo " Processing";

  if($library == 1)
    process_image_imagick($file);
  else
	process_image_gd($file);
}


function process_image_imagick($srcfile)
{ global $verbose, $filter, $trimflag, $cleanflag, $srcdir, $targetdir,$filltype, $fillcolor;
  global $topcut, $rightcut, $bottomcut,$leftcut,$topadd,$rightadd,$bottomadd,$leftadd, $imagetype;
  global $maxwidth, $maxheight,$maxmargin,$maxfillcolor, $suffix;
  
  $src = new Imagick(realpath($srcdir."/".$srcfile));
  if(!$src)
  { pecho ('<b>Image creation failed for file '.$srcfile.'</b><br>');
    return;
  }
  $width  = $src->getImageWidth();
  $height = $src->getImageHeight();
  $format = $src->getImageFormat(); 
  $top=0;
  $left=0;

  /* step 1: trimming */
  if($trimflag)
  { $margins = trimImage_imagick($src);
    $mtop = $margins[0];
	$mright = $margins[1];
    $mbottom = $margins[2];
    $mleft = $margins[3];
	
	$mwidth = $mright-$mleft;
	$mheight = $mbottom-$mtop;
	$width = $mwidth; $height = $mheight;
	$top = $mtop; $left = $mleft;
    $src->cropImage($mwidth, $mheight, $mleft, $mtop);
	$src->setImagePage(0,0,0,0);
	/* No crop here! Two times crop gives strange results! */
  }

  if(($leftcut !=0) || ($rightcut !=0) ||($topcut !=0) ||($bottomcut !=0))
  { $minwidth = $width - $rightcut - $leftcut;
    $minheight = $height - $topcut - $bottomcut;
    $src->cropImage($minwidth, $minheight, $leftcut, $topcut);
	$src->setImagePage(0,0,0,0);
  }
  $newwidth = $width - $rightcut - $leftcut + $rightadd + $leftadd;
  $newheight = $height - $topcut - $bottomcut + $topadd + $bottomadd;
  
  $img = new Imagick();
  $img->newImage($newwidth, $newheight, new ImagickPixel($fillcolor));
  $img->compositeImage($src, imagick::COMPOSITE_DEFAULT, $leftadd, $topadd);
  
  /* implement maxwidth and maxheight */
  if((($maxwidth > 0) && ($newwidth > ($maxwidth+$maxmargin))) || (($maxheight > 0) && ($newheight > ($maxheight+$maxmargin))))
  { if(($maxwidth > 0) && ($newwidth > $maxwidth))
	{ $targetwidth = $maxwidth;
	  $targetheight = $newheight*$targetwidth/$newwidth;
	}
	if(($maxheight > 0) && ($targetheight > $maxheight))
	{ $targetheight = $maxheight;
	  $targetwidth = $newwidth*$targetheight/$newheight;
	}
// if you're doing a lot of picture resizing, it might be beneficial to use scaleImage instead of resizeImage, as it seems to be much much more efficient.

    $img->resizeImage($targetwidth,$targetheight, $filter, 1);
  }

//  $img->setImageCompression(Imagick::COMPRESSION_JPEG);
  $img->setInterlaceScheme(Imagick::INTERLACE_PLANE); /* alternatives: INTERLACE_NONE and INTERLACE_LINE */
  $img->setImageCompressionQuality(94);

  $ww  = $img->getImageWidth();
  $hh = $img->getImageHeight();
  
  if(($imagetype == "jpg") || (($imagetype == "same") && (($format == "JPG") || ($format == "JPEG"))))
    $srcfile = preg_replace('/\.png/','.jpg',$srcfile);
  else
    $srcfile = preg_replace('/\.jpg/','.png',$srcfile);

  if($suffix != "")
	$srcfile = preg_replace('/(\....)$/',$suffix.'$1',$srcfile);

  if(!$img->writeImage($targetdir."/".$srcfile))
	  pecho("Error creating ".$targetdir."/".$srcfile); /* image, filename, quality */
  $img->destroy();

  if ($verbose=="true") echo " ".$format."<br>";
}

function process_image_gd($srcfile)
{ global $verbose, $filter, $trimflag, $cleanflag, $srcdir, $targetdir,$filltype, $fillcolor;
  global $topcut, $rightcut, $bottomcut,$leftcut,$topadd,$rightadd,$bottomadd,$leftadd,$imagetype;
  global $maxwidth, $maxheight,$maxmargin,$maxfillcolor, $suffix;
  
  list($width, $height, $imgtype, $attr) = @getimagesize( $srcdir."/".$srcfile);
  $sourceratio = $width / $height ;

  /* image type constants are defined here: http://php.net/manual/en/function.exif-imagetype.php */
  if($imgtype == IMAGETYPE_GIF)
	$src = imagecreatefromgif($srcdir."/".$srcfile);
  else if($imgtype == IMAGETYPE_PNG)
	$src = imagecreatefrompng($srcdir."/".$srcfile);
  else if($imgtype == IMAGETYPE_JPEG)
	$src = imagecreatefromjpeg($srcdir."/".$srcfile);
  else if($imgtype == IMG_WBMP)
	$src = imagecreatefromwbmp($srcdir."/".$srcfile);
  else if($imgtype == IMAGETYPE_BMP)
	$src = imagecreatefrombmp($srcdir."/".$srcfile);	/* not a GD library function, but defined below */
  else /* if we get an unknown format we try it as a jpg */
  { $src = imagecreatefromjpeg($srcdir."/".$srcfile);
	pecho ('<b>Unknown image Type '.$imgtype.'</b><br>');
  }

  if(!$src)
  { pecho ('<b>Image creation failed for file '.$srcfile.'</b><br>');
    return;
  }
  if($trimflag)
  { $margins = trimImage_gd($src);
    $mtop = $margins[0];
	$mright = $margins[1];
    $mbottom = $margins[2];
    $mleft = $margins[3];
	
	$mwidth = $mright-$mleft;
	$mheight = $mbottom-$mtop;
    $img2 = imagecreatetruecolor ( $mwidth , $mheight ); /* create black image */
    imagecopyresampled($img2, $src, 0, 0, $mleft, $mtop, $mwidth, $mheight, $mwidth, $mheight);
    $src = $img2;
	$width = $mwidth; $height = $mheight; $sourceratio = $width / $height ;
  }
  
  if($cleanflag)
  { $src = cleanImage_gd($src);
  }
  
  $minwidth = $width - $rightcut - $leftcut;
  $minheight = $height - $topcut - $bottomcut;

  $newwidth = $width - $rightcut - $leftcut + $rightadd + $leftadd;
  $newheight = $height - $topcut - $bottomcut + $topadd + $bottomadd;

  $img2 = imagecreatetruecolor ( $newwidth , $newheight ); /* create black image */
  if(($imagetype == "jpg") || (($imagetype == "same") && ($imgtype == IMAGETYPE_JPEG)) || ($fillcolor!=""))
  { if($fillcolor == "") $fillcolor = "#000000";
    $color = imagecolorallocate($img2, hexdec(substr($fillcolor,1,2)), hexdec(substr($fillcolor,3,2)), hexdec(substr($fillcolor,5,2)));
  }
  else /* png transparent */
  { imagealphablending($img2, false);
    imagesavealpha($img2, true);
    $color = imagecolorallocatealpha($img2, 255, 255, 255, 127);
  }
  imagefill($img2, 0, 0, $color);					
  imagecopyresampled($img2, $src, $leftadd, $topadd, $leftcut, $topcut, $minwidth, $minheight, $minwidth, $minheight);
  
  /* implement maxwidth and maxheight */
  if((($maxwidth > 0) && ($newwidth > ($maxwidth+$maxmargin))) || (($maxheight > 0) && ($newheight > ($maxheight+$maxmargin))))
  { if(($maxwidth > 0) && ($newwidth > $maxwidth))
	{ $targetwidth = $maxwidth;
	  $targetheight = $newheight*$targetwidth/$newwidth;
	}
	if(($maxheight > 0) && ($targetheight > $maxheight))
	{ $targetheight = $maxheight;
	  $targetwidth = $newwidth*$targetheight/$newheight;
	}

    $img3 = imagecreatetruecolor ( $targetwidth , $targetheight ); 
    if(($imagetype == "jpg") || (($imagetype == "same") && ($imgtype == IMAGETYPE_JPEG)) || ($maxfillcolor!=""))
    { if($maxfillcolor == "") $maxfillcolor = "#000000";
      $color = imagecolorallocate($img2, hexdec(substr($maxfillcolor,1,2)), hexdec(substr($maxfillcolor,3,2)), hexdec(substr($maxfillcolor,5,2)));
    }
    else /* png transparent */
    { imagealphablending($img2, false);
      imagesavealpha($img3, true);
      $color = imagecolorallocatealpha($img3, 255, 255, 255, 127);
    }
    imagefill($img3, 0, 0, $color);	
	imagecopyresampled($img3, $img2, 0, 0, 0, 0, $targetwidth, $targetheight, $newwidth, $newheight);
	$img2 = $img3;
  }
  
  if($suffix != "")
	$srcfile = preg_replace('/(\....)/',$suffix.'$1',$srcfile);
  
  if(($imagetype == "jpg") ||(($imagetype == "same") && ($imgtype == IMAGETYPE_JPEG)))
  { imageinterlace($img2, 1); /* make the image progressive */
    $srcfile = preg_replace('/\.png/','.jpg',$srcfile);
    if(!imagejpeg($img2, $targetdir."/".$srcfile, 94))
	  pecho("Error creating ".$targetdir."/".$srcfile); /* image, filename, quality (1-99) */
  }
  else
  { $srcfile = preg_replace('/\.jpg/','.png',$srcfile);
    if(!imagepng($img2, $targetdir."/".$srcfile))
	  pecho("Error creating ".$targetdir."/".$srcfile); /* image, filename, compression (1-9) */
  }
  if ($verbose=="true") echo "<br>";
}

function fix_strtolower($str)
{   if( function_exists( 'mb_strtoupper' ) )
	  return mb_strtolower($str);
    else
	  return strtolower($str);
}


function adapt_timelimit($numrecs)
{ global $duration,$marginstrip;
  if($marginstrip) $perimg = 25;
  else $perimg = 2;
  $msg = $numrecs.' images to regenerate.';
  $timeout = $numrecs*$perimg;
  if(($timeout > 30) || ($duration != 0))
  { if($duration > $timeout)
	   $timeout = $duration;
    set_time_limit ($timeout);
	$msg .= ' The timeout has been extended to '.$timeout.' seconds.';
  }
  echo '<script>parent.dynamo2("'.$msg.'");</script>';
}

function pecho($txt)
{ echo $txt;
  echo '<script>parent.dynamo2("'.$txt.'");</script>';
}

/* copied and adapted from http://php.net/manual/en/function.imagecolorat.php */
/* arguments: resource $image , int $colour , int $tolerance */
function trimImage_gd($im)
{ global $trimcolor, $trimtolerance, $trimcount;
  // if trim colour ($c) isn't a number between 0 - 255
  if ((strlen($trimcolor) != 6) || (!ctype_xdigit($trimcolor))) 
  { // grab the colour from the top left corner and use that as default
    $rgb = imagecolorat($im, 2, 2); // 2 pixels in to avoid messy edges
    $r = ($rgb >> 16) & 0xFF;
    $g = ($rgb >> 8) & 0xFF;
    $b = $rgb & 0xFF;
    $rgb = imagecolorat($im, 8, 2); // 2 pixels in to avoid messy edges
    $r += ($rgb >> 16) & 0xFF;
    $g += ($rgb >> 8) & 0xFF;
    $b += $rgb & 0xFF;
    $rgb = imagecolorat($im, 2, 8); // 2 pixels in to avoid messy edges
    $r += ($rgb >> 16) & 0xFF;
    $g += ($rgb >> 8) & 0xFF;
    $b += $rgb & 0xFF;
	$rt = $r/3;
	$gt = $g/3;
	$bt = $b/3;
  }
  else
  { $trimcolorval = hexdec($trimcolor);
    $rt = ($trimcolorval >> 16) & 0xFF;
    $gt = ($trimcolorval >> 8) & 0xFF;
    $bt = $trimcolorval & 0xFF; 
  }

  // if tolerance ($t) isn't a number between 0 - 255 use 10 as default
  if (!is_numeric($trimtolerance) || $trimtolerance < 0 || $trimtolerance > 255) $trimtolerance = 50;
//  echo "BT=".$bt." GT=".$gt." RT=".$rt." TT=".$trimtolerance;
  // Calculate these once rather than for every iteration

  $w = imagesx($im); // image width
  $h = imagesy($im); // image height
  $x_axis=$y_axis=array();
  for($i=0;$i<$w; $i++) $x_axis[$i]=0;
  for($i=0;$i<$h; $i++) $y_axis[$i]=0;
  for($x = 0; $x < $w; $x++) {
    for($y = 0; $y < $h; $y++) {
      $rgb = imagecolorat($im, $x, $y);
      $r = ($rgb >> 16) & 0xFF;
      $g = ($rgb >> 8) & 0xFF;
      $b = $rgb & 0xFF;
	  $diff = abs($rt-$r)+abs($gt-$g)+abs($bt-$b);
      if ($diff > $trimtolerance) 
	  { //echo "<br>".$r."-".$g."-".$b."=".$diff." (".$x.",",$y.")";
        $y_axis[$y]++;
        $x_axis[$x]++;
      }
    }
  }
  // sort them so first and last occurances are at start and end

  for($y=0; $y<$h-1; $y++)
  { if(($y_axis[$y] >= $trimcount) && ($y_axis[$y+1] >= $trimcount))
	  {$top = $y; break; }
  }
  for($y=$h-1; $y>0; $y--)
  { if(($y_axis[$y] >= $trimcount) && ($y_axis[$y-1] >= $trimcount))
	  {$bottom = $y; break; }
  }
  for($x=0; $x<$w-1; $x++)
  { if(($x_axis[$x] >= $trimcount) && ($x_axis[$x+1] >= $trimcount))
	  {$left = $x; break; }
  }
  for($x=$w-1; $x>0; $x--)
  { if(($x_axis[$x] >= $trimcount) && ($x_axis[$x-1] >= $trimcount))
	  {$right = $x; break; }
  }

 // echo "<br>XXS-top=".$top."-right=".$right."-bottom=".$bottom."-left=".$left."<br>"; 
    /* add a 2% margin */
    $wmargin = intval(2*($right-$left)/100);
    $hmargin = intval(2*($bottom-$top)/100);
    $top = $top-$hmargin;
    if($top <0) $top=0;
    $right = $right+$wmargin;
    if($right >= $w) $right = $w-1;
    $bottom = $bottom+$hmargin;
    if($bottom >= $h) $bottom = $h-1;
    $left = $left-$wmargin;
    if($left <0) $left=0;

  return array($top,$right,$bottom,$left);
}

/* copied and adapted from http://php.net/manual/en/function.imagecolorat.php */
/* arguments: resource $image , int $colour , int $tolerance */
function trimImage_imagick($im) 
{ global $trimcolor, $trimtolerance, $trimcount;
  if ((strlen($trimcolor) != 6) || (!ctype_xdigit($trimcolor))) 
  { // grab the colour from the top left corner and use that as default
	$pixel = $im->getImagePixelColor(2, 2);
    $rgb = $pixel->getColor();
    $r = $rgb['r'];
    $g = $rgb['g'];
    $b = $rgb['b'];
	$pixel = $im->getImagePixelColor(8, 2);
    $rgb = $pixel->getColor();
    $r += $rgb['r'];
    $g += $rgb['g'];
    $b += $rgb['b'];
	$pixel = $im->getImagePixelColor(2, 8);
    $rgb = $pixel->getColor();
    $r += $rgb['r'];
    $g += $rgb['g'];
    $b += $rgb['b'];
	$rt = $r/3;
	$gt = $g/3;
	$bt = $b/3;
  }
  else
  { $trimcolorval = hexdec($trimcolor);
    $rt = ($trimcolorval >> 16) & 0xFF;
    $gt = ($trimcolorval >> 8) & 0xFF;
    $bt = $trimcolorval & 0xFF; 
  }
  
  // if tolerance ($t) isn't a number between 0 - 255 use 50 as default
  if (!is_numeric($trimtolerance) || $trimtolerance < 0 || $trimtolerance > 255) $trimtolerance = 50;

  $w = $im->getImageWidth(); // image width
  $h = $im->getImageHeight(); // image height

  // Calculate these once rather than for every iteration
  $x_axis=$y_axis=array();
  for($i=0;$i<$w; $i++) $x_axis[$i]=0;
  for($i=0;$i<$h; $i++) $y_axis[$i]=0;

  $iterator = $im->getPixelIterator();
  foreach( $iterator as $y => $row ) {
    foreach( $row as $x => $pixel ) {
      $rgb = $pixel->getColor();
      $r = $rgb['r'];
      $g = $rgb['g'];
      $b = $rgb['b'];
	  $diff = abs($rt-$r)+abs($gt-$g)+abs($bt-$b);
      if ($diff > $trimtolerance) 
	  { $y_axis[$y]++;
        $x_axis[$x]++;
      }
    }
    $iterator->syncIterator();
  }

  for($y=0; $y<$h-1; $y++)
  { if(($y_axis[$y] >= $trimcount) && ($y_axis[$y+1] >= $trimcount))
	  {$top = $y; break; }
  }
  for($y=$h-1; $y>0; $y--)
  { if(($y_axis[$y] >= $trimcount) && ($y_axis[$y-1] >= $trimcount))
	  {$bottom = $y; break; }
  }
  for($x=0; $x<$w-1; $x++)
  { if(($x_axis[$x] >= $trimcount) && ($x_axis[$x+1] >= $trimcount))
	  {$left = $x; break; }
  }
  for($x=$w-1; $x>0; $x--)
  { if(($x_axis[$x] >= $trimcount) && ($x_axis[$x-1] >= $trimcount))
	  {$right = $x; break; }
  }
	
    /* add a 2% margin */
    $wmargin = intval(2*($right-$left)/100);
    $hmargin = intval(2*($bottom-$top)/100);
    $top = $top-$hmargin;
    if($top <0) $top=0;
    $right = $right+$wmargin;
    if($right >= $w) $right = $w-1;
    $bottom = $bottom+$hmargin;
    if($bottom >= $h) $bottom = $h-1;
    $left = $left-$wmargin;
    if($left <0) $left=0;

  return array($top,$right,$bottom,$left);
}

function cleanImage_gd($src)
{ global $cleantolerance, $cleancolors;
  $margins = trimImage_gd($src);
  $mtop = $margins[0];
  $mright = $margins[1];
  $mbottom = $margins[2];
  $mleft = $margins[3];
  $mwidth = $mright-$mleft;
  $mheight = $mbottom-$mtop;
  $w = imagesx($src); // image width
  $h = imagesy($src); // image height
  $img2 = imagecreatetruecolor ( $w , $h ); /* create black image */
  $mycolor = imagecolorallocate($img2, $cleancolors[0], $cleancolors[1], $cleancolors[2]);
  imagefill($img2, 0, 0, $mycolor);						/* make it white */
  imagecopyresampled($img2, $src, $mleft, $mtop, $mleft, $mtop, $mwidth, $mheight, $mwidth, $mheight);

/* in the following we get the pixels from $src and we write to $img2 */
  for($x = $mleft; $x < $mright; $x++) 
  { for($y = $mtop; $y < $mbottom; $y++) 
	{ /* we start top down */
	  /* first the front */
	  $rgbs=$r=$g=$b=array();
      $rgbs[] = imagecolorat($src, $x, $y);
	  if($y < $h-1) $rgbs[] = imagecolorat($src, $x, $y+1);
//	  if($y < $h-2) $rgbs[] = imagecolorat($src, $x, $y+2);
	  if($x>0) $rgbs[] = imagecolorat($src, $x-1, $y);
//	  if($x>1) $rgbs[] = imagecolorat($src, $x-2, $y);	  
	  if($x < $w-1) $rgbs[] = imagecolorat($src, $x+1, $y);
//	  if($x < $w-2) $rgbs[] = imagecolorat($src, $x+2, $y);
	  if(($x < $w-1) && ($y < $h-1)) $rgbs[] = imagecolorat($src, $x+1, $y+1);
	  if(($x>0) && ($y < $h-1)) $rgbs[] = imagecolorat($src, $x-1, $y+1);
	  foreach($rgbs AS $rgb)
      { $r[] = ($rgb >> 16) &  0xFF;
        $g[] = ($rgb >> 8) & 0xFF;
        $b[] = $rgb & 0xFF;
	  }
	  $fields = array_merge($r,$g,$b);
	  $avgr = array_sum($r) / count($r);
	  $avgg = array_sum($g) / count($g);
	  $avgb = array_sum($b) / count($b);
	  $avg = array_sum($fields) / count($fields);
	  
	  /* now the back */
	  $rgbs=$r=$g=$b=array();
	  if(($x < $w-1) && ($y < $mbottom-1)) $rgbs[] = imagecolorat($src, $x+1, $y-1);
	  if($y < $h-1) $rgbs[] = imagecolorat($src, $x, $y-1);
	  if(($x > 0) && ($y < $mbottom-1)) $rgbs[] = imagecolorat($src, $x-1, $y-1);
	  if(($x < $w-1) && ($y < $mbottom-2)) $rgbs[] = imagecolorat($src, $x+1, $y-2);
	  if($y < $h-2) $rgbs[] = imagecolorat($src, $x, $y-2);
	  if(($x > 0) && ($y < $h-2)) $rgbs[] = imagecolorat($src, $x-1, $y-2);
	  foreach($rgbs AS $rgb)
      { $r[] = ($rgb >> 16) &  0xFF;
        $g[] = ($rgb >> 8) & 0xFF;
        $b[] = $rgb & 0xFF;
	  }
	  $fields = array_merge($r,$g,$b);
	  $bavgr = array_sum($r) / count($r);
	  $bavgg = array_sum($g) / count($g);
	  $bavgb = array_sum($b) / count($b);
	  $bavg = array_sum($fields) / count($fields);

	  /* get differences */
	  $diffr = abs($bavgr - $avgr);
	  $diffg = abs($bavgg - $avgg);	  
	  $diffb = abs($bavgb - $avgb);	  
	  $diff = abs($bavg - $avg);	  
	  
	  if((($diffr > $cleantolerance) || ($diffg > $cleantolerance) || ($diffb > $cleantolerance)) && ($diff > $cleantolerance))	  
	  { break;
	  }
	  else
	  { imagesetpixel($img2,$x,$y,$mycolor); 
	  }
    }
	$memory = $y;
	
    for($y = $mbottom; $y > $memory; $y--) 
	{ /* now bottom up */
	  /* first the front */
	  /* first check whether the new bg color is already implemented */
	  $rgb = imagecolorat($img2, $x, $y);
	  if(((($rgb >> 16) &  0xFF) == $cleancolors[0]) && ((($rgb >> 8) &  0xFF) == $cleancolors[1]) && (($rgb & 0xFF) == $cleancolors[2]))
		 continue;
	  
	  $rgbs=$r=$g=$b=array();
      $rgbs[] = imagecolorat($src, $x, $y);
	  if($y >0) $rgbs[] = imagecolorat($src, $x, $y-1);
//	  if($y >1 ) $rgbs[] = imagecolorat($src, $x, $y-2);
	  if($x>0) $rgbs[] = imagecolorat($src, $x-1, $y);
//	  if($x>1) $rgbs[] = imagecolorat($src, $x-2, $y);	  
	  if($x < $w-1) $rgbs[] = imagecolorat($src, $x+1, $y);
//	  if($x < $w-2) $rgbs[] = imagecolorat($src, $x+2, $y);
	  if(($x < $w-1) && ($y < $h-1)) $rgbs[] = imagecolorat($src, $x+1, $y-1);
	  if(($x>0) && ($y < $h-1)) $rgbs[] = imagecolorat($src, $x-1, $y-1);
	  foreach($rgbs AS $rgb)
      { $r[] = ($rgb >> 16) &  0xFF;
        $g[] = ($rgb >> 8) & 0xFF;
        $b[] = $rgb & 0xFF;
	  }
	  $fields = array_merge($r,$g,$b);
	  $avgr = array_sum($r) / count($r);
	  $avgg = array_sum($g) / count($g);
	  $avgb = array_sum($b) / count($b);
	  $avg = array_sum($fields) / count($fields);
	  
	  /* now the back */
	  $rgbs=$r=$g=$b=array();
	  if(($x < $w-1) && ($y < $h-1)) $rgbs[] = imagecolorat($src, $x+1, $y+1);
	  if($y < $h-1) $rgbs[] = imagecolorat($src, $x, $y-1);
	  if(($x > 0) && ($y < $h-1)) $rgbs[] = imagecolorat($src, $x-1, $y+1);
	  if(($x < $w-1) && ($y < $h-2)) $rgbs[] = imagecolorat($src, $x+1, $y+2);
	  if($y < $h-2) $rgbs[] = imagecolorat($src, $x, $y+2);
	  if(($x > 0) && ($y < $h-2)) $rgbs[] = imagecolorat($src, $x-1, $y+2);
	  foreach($rgbs AS $rgb)
      { $r[] = ($rgb >> 16) &  0xFF;
        $g[] = ($rgb >> 8) & 0xFF;
        $b[] = $rgb & 0xFF;
	  }
	  $fields = array_merge($r,$g,$b);
	  $bavgr = array_sum($r) / count($r);
	  $bavgg = array_sum($g) / count($g);
	  $bavgb = array_sum($b) / count($b);
	  $bavg = array_sum($fields) / count($fields);

	  /* get differences */
	  $diffr = abs($bavgr - $avgr);
	  $diffg = abs($bavgg - $avgg);	  
	  $diffb = abs($bavgb - $avgb);	  
	  $diff = abs($bavg - $avg);	  
	  
	  if((($diffr > $cleantolerance) || ($diffg > $cleantolerance) || ($diffb > $cleantolerance)) && ($diff > $cleantolerance))	  
	  { break;
	  }
	  else
	  { imagesetpixel($img2,$x,$y,$mycolor); 
	  }
    }
  }

  for($y = $mtop; $y < $mbottom; $y++) 
  { for($x = $mleft; $x < $mright; $x++) 
	{ /* we start left to right */
	  /* first the front */
	  /* first check whether the new bg color is already implemented */
	  $rgb = imagecolorat($img2, $x, $y);
	  if(((($rgb >> 16) &  0xFF) == $cleancolors[0]) && ((($rgb >> 8) &  0xFF) == $cleancolors[1]) && (($rgb & 0xFF) == $cleancolors[2]))
		 continue;
	  
	  $rgbs=$r=$g=$b=array();
      $rgbs[] = imagecolorat($src, $x, $y);
	  if($y < $h-1) $rgbs[] = imagecolorat($src, $x, $y+1);
//	  if($y < $h-2) $rgbs[] = imagecolorat($src, $x, $y+2);
	  if($y>0) $rgbs[] = imagecolorat($src, $x, $y-1);
//	  if($y>1) $rgbs[] = imagecolorat($src, $x, $y-2);	  
	  if($x < $w-1) $rgbs[] = imagecolorat($src, $x+1, $y);
//	  if($x < $w-2) $rgbs[] = imagecolorat($src, $x+2, $y);
	  if(($x < $w-1) && ($y < $h-1)) $rgbs[] = imagecolorat($src, $x+1, $y+1);
	  if(($x < $w-1) && ($y >0)) $rgbs[] = imagecolorat($src, $x+1, $y-1);
	  foreach($rgbs AS $rgb)
      { $r[] = ($rgb >> 16) &  0xFF;
        $g[] = ($rgb >> 8) & 0xFF;
        $b[] = $rgb & 0xFF;
	  }
	  $fields = array_merge($r,$g,$b);
	  $avgr = array_sum($r) / count($r);
	  $avgg = array_sum($g) / count($g);
	  $avgb = array_sum($b) / count($b);
	  $avg = array_sum($fields) / count($fields);
	  
	  /* now the back */
	  $rgbs=$r=$g=$b=array();
	  if(($x < $w-1) && ($y < $mbottom-1)) $rgbs[] = imagecolorat($src, $x+1, $y-1);
	  if($y < $h-1) $rgbs[] = imagecolorat($src, $x, $y-1);
	  if(($x > 0) && ($y < $mbottom-1)) $rgbs[] = imagecolorat($src, $x-1, $y-1);
	  if(($x < $w-1) && ($y < $mbottom-2)) $rgbs[] = imagecolorat($src, $x+1, $y-2);
	  if($y < $h-2) $rgbs[] = imagecolorat($src, $x, $y-2);
	  if(($x > 0) && ($y < $h-2)) $rgbs[] = imagecolorat($src, $x-1, $y-2);
	  foreach($rgbs AS $rgb)
      { $r[] = ($rgb >> 16) &  0xFF;
        $g[] = ($rgb >> 8) & 0xFF;
        $b[] = $rgb & 0xFF;
	  }
	  $fields = array_merge($r,$g,$b);
	  $bavgr = array_sum($r) / count($r);
	  $bavgg = array_sum($g) / count($g);
	  $bavgb = array_sum($b) / count($b);
	  $bavg = array_sum($fields) / count($fields);

	  /* get differences */
	  $diffr = abs($bavgr - $avgr);
	  $diffg = abs($bavgg - $avgg);	  
	  $diffb = abs($bavgb - $avgb);	  
	  $diff = abs($bavg - $avg);	  
	  
	  if((($diffr > $cleantolerance) || ($diffg > $cleantolerance) || ($diffb > $cleantolerance)) && ($diff > $cleantolerance))	  
	  { break;
	  }
	  else
	  { imagesetpixel($img2,$x,$y,$mycolor); 
	  }
    }
	$memory = $x;
	
    for($x = $mright; $x >$memory; $x--) 
	{ /* now right to left */
	  /* first the front */
	  /* first check whether the new bg color is already implemented */
	  $rgb = imagecolorat($img2, $x, $y);
	  if(((($rgb >> 16) &  0xFF) == $cleancolors[0]) && ((($rgb >> 8) &  0xFF) == $cleancolors[1]) && (($rgb & 0xFF) == $cleancolors[2]))
		 continue;
	  
	  $rgbs=$r=$g=$b=array();
      $rgbs[] = imagecolorat($src, $x, $y);
	  if($y >0) $rgbs[] = imagecolorat($src, $x, $y-1);
//	  if($y >1 ) $rgbs[] = imagecolorat($src, $x, $y-2);
	  if($x>0) $rgbs[] = imagecolorat($src, $x-1, $y);
//	  if($x>1) $rgbs[] = imagecolorat($src, $x-2, $y);	  
	  if($y < $h-1) $rgbs[] = imagecolorat($src, $x, $y+1);
//	  if($y < $h-2) $rgbs[] = imagecolorat($src, $x, $y+2);
	  if(($x > 0) && ($y < $h-1)) $rgbs[] = imagecolorat($src, $x-1, $y+1);
	  if(($x>0) && ($y > 0)) $rgbs[] = imagecolorat($src, $x-1, $y-1);
	  foreach($rgbs AS $rgb)
      { $r[] = ($rgb >> 16) &  0xFF;
        $g[] = ($rgb >> 8) & 0xFF;
        $b[] = $rgb & 0xFF;
	  }
	  $fields = array_merge($r,$g,$b);
	  $avgr = array_sum($r) / count($r);
	  $avgg = array_sum($g) / count($g);
	  $avgb = array_sum($b) / count($b);
	  $avg = array_sum($fields) / count($fields);
	  
	  /* now the back */
	  $rgbs=$r=$g=$b=array();
	  if(($x < $w-1) && ($y < $h-1)) $rgbs[] = imagecolorat($src, $x+1, $y+1);
	  if($y < $h-1) $rgbs[] = imagecolorat($src, $x, $y-1);
	  if(($x < $w-1) && ($y > 0)) $rgbs[] = imagecolorat($src, $x+1, $y-1);
	  if(($x < $w-1) && ($y < $h-2)) $rgbs[] = imagecolorat($src, $x+1, $y+2);
	  if($y < $h-2) $rgbs[] = imagecolorat($src, $x, $y+2);
	  if(($x< $w-1) && ($y > 1)) $rgbs[] = imagecolorat($src, $x+1, $y-2);
	  foreach($rgbs AS $rgb)
      { $r[] = ($rgb >> 16) &  0xFF;
        $g[] = ($rgb >> 8) & 0xFF;
        $b[] = $rgb & 0xFF;
	  }
	  $fields = array_merge($r,$g,$b);
	  $bavgr = array_sum($r) / count($r);
	  $bavgg = array_sum($g) / count($g);
	  $bavgb = array_sum($b) / count($b);
	  $bavg = array_sum($fields) / count($fields);

	  /* get differences */
	  $diffr = abs($bavgr - $avgr);
	  $diffg = abs($bavgg - $avgg);	  
	  $diffb = abs($bavgb - $avgb);	  
	  $diff = abs($bavg - $avg);	  
	  
	  if((($diffr > $cleantolerance) || ($diffg > $cleantolerance) || ($diffb > $cleantolerance)) && ($diff > $cleantolerance))	  
	  { break;
	  }
	  else
	  { imagesetpixel($img2,$x,$y,$mycolor); 
	  }
    }
  }
  
  return $img2;	
}